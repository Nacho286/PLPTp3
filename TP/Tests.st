Object subclass: #Card	instanceVariableNames: 'valor type'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Card methodsFor: 'comparing' stamp: 'nicolas 6/22/2017 00:34'!= otro	^ (valor = otro getValor) & (type = otro  getType )! !!Card methodsFor: 'comparing' stamp: 'nicolas 6/18/2017 02:50'!~= otro	^ ((otro isMemberOf: self class) not) or: [^ (self equals: otro) not].	! !!Card methodsFor: 'comparing' stamp: 'nicolas 6/19/2017 00:27'!equals: otraCarta	^ self = otraCarta ! !!Card methodsFor: 'accessing' stamp: 'nicolas 6/11/2017 01:28'!getType	^type! !!Card methodsFor: 'accessing' stamp: 'nicolas 6/11/2017 01:20'!getValor	^valor! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Card class	instanceVariableNames: ''!!Card class methodsFor: 'instance creation' stamp: 'IgnacioRodriguez 6/10/2017 10:40'!new: val	|unaInstancia|	unaInstancia := self new.	unaInstancia inicializar: val.	^unaInstancia ! !Card subclass: #GoalCard	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!GoalCard methodsFor: 'testing' stamp: 'nicolas 6/22/2017 00:51'!isMetBy: aSet	|interseccion|	"Determina si  aSet cumple con el goal que especifico. Es decir, si mi goal esta contenido dentro de el"	interseccion := (valor intersection: aSet).	^(interseccion  size = valor size) and: [interseccion  includesAllOf: valor]! !!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/11/2017 01:35'!inicializar: val	"comment stating purpose of message"	valor:=val.	type:= #Goal.! !!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/16/2017 00:44'!hash^ valor hash! !!GoalCard methodsFor: 'instance creation' stamp: 'IgnacioRodriguez 6/20/2017 13:02'!includes: unSet ^ valor includes: unSet ! !!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/20/2017 19:36'!content	^ valor! !!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/22/2017 00:47'!playCard: juego"Soy jugada, modificando el goal actual y removiendome de la mano del jugador actual"(juego currentPlayer mano) remove: self ifAbsent:[]. juego setGoal: self.! !!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/22/2017 00:51'!printString	^ valor asCommaString ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GoalCard class	instanceVariableNames: ''!!GoalCard class methodsFor: 'instance creation' stamp: 'nicolas 6/15/2017 23:29'!new: val	|instance|	instance := self new.	instance inicializar: val.	^ instance! !Object subclass: #MiniFluxxGame	instanceVariableNames: 'jugadores mazo goal winner'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:10'!deckSize^ mazo size ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'nicolas 6/22/2017 01:03'!playGame"Mientras haya mazo, mis jugadores juegan turnos segun las reglas"[mazo isEmpty ] whileFalse: [ self play1Turn ]."Si el mazo se acaba, hay que terminar de jugar hasta que no haya jugadores con manos o se encuentre un ganador. El primer caso es un empate"[ self currentPlayer hasCards and: self winner isNil ] whileTrue: [ self play1Turn ].! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:10'!players^ jugadores ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:35'!setGoal: newGoalgoal := newGoal. ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 19:54'!goal^ goal ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'nicolas 6/22/2017 01:01'!pass"Cambio el jugador actual  llevandolo al final de la colección de jugadores. El nuevo actual es el proximo"|elem|elem := jugadores removeFirst .jugadores addLast: elem.! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'nicolas 6/22/2017 01:04'!setStrategy: aBlock forPlayer: unJugador"Selecciona a unJugador de mis jugadores y si existe, dicho jugador ahora tiene una estrategia que esta indicada por aBlock"jugadores detect: [:jugador| jugador name = unJugador] ifFound:[:jugador|jugador strategy:aBlock].  ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'nicolas 6/22/2017 01:08'!winner"Devuelvo el ganador actual. Puede ser nulo"|aux|aux:=OrderedCollection newFrom: jugadores."Si no hay goal, no hay ganador"goal ifNil:[^nil]."Busco en mis jugadores aquellos cuya mesa no cumpla el goal. Si estos son no nulos, designo al ganador como el primero de ellos. Si no, no hay ganador(nil)"aux removeAllSuchThat: [:each | (goal isMetBy: each mesa) not].aux ifNotEmpty:[^aux at: 1].^nil  ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'nicolas 6/22/2017 01:02'!play1Turn"Juego un turno segun las reglas del juego""Agarro carta si hay"mazo ifNotEmpty: [self currentPlayer pickFrom: mazo] .self currentPlayer play:self.self pass.  ! !!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'nicolas 6/22/2017 00:59'!inicializar: deck playerNames: players cardsPlayers:n"Inicializo a mis jugadores y mazo"|cantCartas|cantCartas :=n.mazo := deck."Si no puedo dar suficientes(n) cartas a cada uno, canCartas por jugador sera 0"(mazo size< (players size * n)) ifTrue:[		cantCartas:=0 ].jugadores :=  OrderedCollection new."Inicializo a los jugadores dandole una cantidad adecuada,cantCartas, provenientes de mazo"players do: [:val| jugadores  addLast:((MiniFluxxPlayer new: val) receive: cantCartas  cardsFrom:mazo) ].^self ! !!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'todo 6/19/2017 19:53'!currentPlayer^ jugadores at:1 ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MiniFluxxGame class	instanceVariableNames: ''!!MiniFluxxGame class methodsFor: 'as yet unclassified' stamp: 'todo 6/19/2017 19:13'!withDeck: deck playerNames: players cardsPerPlayer: n|instancia|instancia := self new.instancia inicializar: deck playerNames: players cardsPlayers:n.^instancia ! !Object subclass: #MiniFluxxPlayer	instanceVariableNames: 'nombre mano mesa strategia'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:15'!pickFrom: deck|elem|elem := deck removeFirst.mano addLast: elem.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:10'!handSize^ mano size! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!inicializar: nommano := OrderedCollection new.nombre := nom.mesa := OrderedCollection new.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:10'!name^nombre! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:16'!receive: n cardsFrom: deck|cards|cards := deck removeFirst:n.mano addAllLast: cards.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!meets: goal	^goal isMetBy: mesa ! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 21:42'!mano^mano! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 16:49'!strategy: aBlockstrategia := aBlock.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/22/2017 01:10'!play: juego"Hago una jugada segun las reglas""Si no tengo estrategia definida, juego la primer carta que tengo en mi mano"strategia ifNil: [(mano at:1) playCard: juego]. "Si tengo estrategia definida, juego la carta que esta determinada por esta"strategia ifNotNil: [(strategia value:mano value:mesa value:juego) playCard: juego].! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!mesa^mesa! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!table^mesa! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:10'!hasCards^ mano size >= 1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MiniFluxxPlayer class	instanceVariableNames: ''!!MiniFluxxPlayer class methodsFor: 'instance creation' stamp: 'nicolas 6/19/2017 02:12'!new: val	|unaInstancia|	unaInstancia := self new.	unaInstancia inicializar: val.	^unaInstancia ! !TestCase subclass: #Test01Cards	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/18/2017 02:01'!test01_4CardsAreReadable	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: ('*tea*' match: t1 printString).	self assert: ('*cookies*' match: t2 printString). 	self assert: ('*tea*' match: s1 printString).	self assert: ('*milk*' match: s1 printString).! !!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/19/2017 00:13'!test01_1TreasureCardsEquality	 self assert:((TreasureCard new: #tea) ~= (TreasureCard new: #cookies)).	 self assert:((TreasureCard new: #tea) ~= #tea). 	 self assert:((Set with: (TreasureCard new: #tea)) includes: (TreasureCard new: #tea)).	 self assert:((Set with: (TreasureCard new: #cookies)) includes: (TreasureCard new: #tea)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/18/2017 02:01'!test01_3MeetingGoals	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: (s1 isMetBy: (Set with: t1 with: t3)).	self assert: (s1 isMetBy: (Set with: t1 with: t2 with: t3)).	self assert: (s1 isMetBy: (Set with: t1 with: t2)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/18/2017 02:00'!test01_2GoalCardsEquality	|t1 t2 t3 s1 s2 s3 s4|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := Set with: t1 with: t2.	s2 := Set with: t2 with: t3.	s3 := Set with: t3 with: t2.	s4 := Set with: t3 with: t1.	self assert: ((GoalCard new: s1) equals: (GoalCard new: s1)).	self assert: ((GoalCard new: s2) equals: (GoalCard new: s3)).   self assert: ((GoalCard new: s2) ~= (GoalCard new: s4)).	self assert: ((TreasureCard new: s1) ~= s1).	self assert: ((Set with: (GoalCard new: s1)) includes: (GoalCard new: s1)).	self assert: ((Set with: (GoalCard new: s2)) includes: (GoalCard new: s1)) not.! !!Test01Cards methodsFor: 'tests' stamp: 'nicolas 6/18/2017 01:57'!test01	self assert: ((TreasureCard new: #tea) equals: (TreasureCard new: #tea)).	self assert: ((TreasureCard new: #tea) ~= (TreasureCard new: #cookies)).	self assert: ((TreasureCard new: #tea) ~= #tea).		! !TestCase subclass: #Test02Players	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_3ReceiveFromDeck	| ana deck |	ana := MiniFluxxPlayer new: #Ana.	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	ana receive: 2 cardsFrom: deck.	self assert: ana handSize equals: 2.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_2HandAndDeck	| ana goal deck |	ana := MiniFluxxPlayer new: #Ana.	goal := GoalCard new: (Set with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies)).	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	self assert: (goal isMetBy: deck).	ana pickFrom: deck.	self assert: (goal isMetBy: deck) not.	self assert: ana handSize equals: 1.	ana pickFrom: deck.	self assert: ana handSize equals: 2.	self assert: ana hasCards.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:31'!test02_1PlayerCreation	| ana |	ana := MiniFluxxPlayer new: #Ana.	self assert: ana name equals: #Ana.	self assert: ana handSize equals: 0.	self assert: ana hasCards not.	self assert: ana table isEmpty.! !TestCase subclass: #Test03Games	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 6/8/2017 15:00'!test03_5SinglePlayerGame	| game goal |	game := MiniFluxxGame withDeck: self testDeck playerNames: #(Uno) cardsPerPlayer: 3.	goal := GoalCard new: (Set with: (TreasureCard new: #rocket) with: (TreasureCard new: #moon)).	[game winner] whileNil: [game play1Turn].	self assert: game deckSize equals: 7.	self assert: game winner table size equals: 6.	self assert: game winner handSize equals: 3.	self assert: game goal equals: goal.	self assert: game winner name equals: #Uno.	self assert: game currentPlayer equals: game winner.	self assert: (game currentPlayer meets: goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_2TooManyCards	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 10.	self assert: game currentPlayer name equals: #Ana.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 0.	self assert: game deckSize equals: 20.! !!Test03Games methodsFor: 'testing' stamp: 'IgnacioRodriguez 6/22/2017 00:10'!test03_7PlayWholeGame	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #milk)).	self assert: game winner name equals: #Juan.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p handSize = 2 ]).	self assert: ((game players detect: [:p | p name = #Juan]) meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 6/8/2017 14:53'!test03_6Strategies	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game currentPlayer strategy: st1.	game setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	4 timesRepeat: [game play1Turn].	self assert: game deckSize equals: 8.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Ana.	self assert: game currentPlayer table isEmpty.	self assert: (game players allSatisfy: [:p | p name = #Ana | p table isNotEmpty ]).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:40'!test03_4Play1Turn	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game play1Turn.	self assert: game deckSize equals: 11.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Pedro.! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 14:32'!test03_3Pass	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game pass.	self assert: game currentPlayer name equals: #Pedro.	game pass.	self assert: game currentPlayer name equals: #Marina.	game pass.	self assert: game currentPlayer name equals: #Juan.	game pass.	self assert: game currentPlayer name equals: #Ana.! !!Test03Games methodsFor: 'testing' stamp: 'IgnacioRodriguez 6/22/2017 00:08'!test03_8PlayWholeGameWithReverseDeck	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck reverse playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #cookies)).	self assert: game winner name equals: #Ana.	self assert: game winner handSize equals: 1.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game winner meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_1Initialization	| players game | 	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	self assert: game goal isNil.	self assert: game winner isNil.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 2.	self assert: game deckSize equals: 12.! !!Test03Games methodsFor: 'testing' stamp: 'IgnacioRodriguez 6/20/2017 21:57'!test03_9GameEndsInADraw	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: (self testDeck remove: (TreasureCard new: #milk) ; yourself) 							                         playerNames: players cardsPerPlayer: 2.	self assert: game deckSize equals: 11.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #love)).	"self assert: game winner isNil.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p hasCards not ]).	self assert: (game players allSatisfy: [:p | (p meets: game goal) not ])."! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:08'!testStrategy1	^self class testStrategy1! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^self class testStrategy2.! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck ^self class testDeck! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Test03Games class	instanceVariableNames: ''!!Test03Games class methodsFor: 'for testing' stamp: 'nicolas 6/20/2017 19:25'!testStrategy1^ [ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ t includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^[ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ (t union: h) includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck|   t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10  g0 g1 g2 g3 g4 g5 g6 g7 g8|t0 := TreasureCard new: #chocolate.t1 := TreasureCard new: #rocket.t2 := TreasureCard new: #moon.t3 := TreasureCard new: #cookies.t4 := TreasureCard new: #money.t5 := TreasureCard new: #love.t6 := TreasureCard new: #peace.t7 := TreasureCard new: #milk.t8 := TreasureCard new: #tea.t9 := TreasureCard new: #time.t10 := TreasureCard new: #hammer.g0 := GoalCard new: (Set with: t0 with: t3).g1 := GoalCard new: (Set with: t1 with: t2).g2 := GoalCard new: (Set with: t5 with: t6).g3 := GoalCard new: (Set with: t7 with: t8).g4 := GoalCard new: (Set with: t9 with: t4).g5 := GoalCard new: (Set with: t3 with: t8).g6 := GoalCard new: (Set with: t0 with: t7).g7 := GoalCard new: (Set with: t9 with: t10).g8 := GoalCard new: (Set with: t3 with: t7).^OrderedCollection new add: g4; add: t5; add: t0; add: g3; add: t6; add: t1; add: g8; add: t7; add: t2; add: g1; add: t8; add: t3; add: g0; add: t9; add: t4 ; add: g5; add: t10; add: g6; add: g7; add: g2 ; yourself.! !Card subclass: #TreasureCard	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!TreasureCard methodsFor: 'instance creation' stamp: 'nicolas 6/22/2017 00:52'!playCard: juego"Soy jugada, agregandome al final de las cartas en la mesa y removiendome de la mano del jugador actual"(juego currentPlayer mano) remove: self ifAbsent:[]. juego currentPlayer mesa addLast: self.! !!TreasureCard methodsFor: 'instance creation' stamp: 'nicolas 6/11/2017 01:35'!inicializar: val	"comment stating purpose of message"	valor:=val.	type:= #Treasure.! !!TreasureCard methodsFor: 'instance creation' stamp: 'nicolas 6/19/2017 00:46'!printString	^ valor! !!TreasureCard methodsFor: 'instance creation' stamp: 'nicolas 6/22/2017 00:51'!hash^ valor hash.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TreasureCard class	instanceVariableNames: ''!!TreasureCard class methodsFor: 'instance creation' stamp: 'nicolas 6/15/2017 23:29'!new: val	|instance|	instance := self new.	instance inicializar: val.	^ instance! !