Object subclass: #Card	instanceVariableNames: 'valor type'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Card methodsFor: 'comparing' stamp: 'nicolas 6/19/2017 00:27'!= otro	^ (valor = otro getValor) & (type = otro  getType )! !!Card methodsFor: 'comparing' stamp: 'nicolas 6/18/2017 02:50'!~= otro	^ ((otro isMemberOf: self class) not) or: [^ (self equals: otro) not].	! !!Card methodsFor: 'comparing' stamp: 'nicolas 6/19/2017 00:27'!equals: otraCarta	^ self = otraCarta ! !!Card methodsFor: 'accessing' stamp: 'nicolas 6/11/2017 01:28'!getType	^type! !!Card methodsFor: 'accessing' stamp: 'nicolas 6/11/2017 01:20'!getValor	^valor! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Card class	instanceVariableNames: ''!!Card class methodsFor: 'instance creation' stamp: 'IgnacioRodriguez 6/10/2017 10:40'!new: val	|unaInstancia|	unaInstancia := self new.	unaInstancia inicializar: val.	^unaInstancia ! !Card subclass: #GoalCard	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/16/2017 00:44'!hash^ valor hash! !!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/11/2017 01:35'!inicializar: val	"comment stating purpose of message"	valor:=val.	type:= #Goal.! !!GoalCard methodsFor: 'instance creation' stamp: 'IgnacioRodriguez 6/20/2017 13:02'!includes: unSet ^ valor includes: unSet ! !!GoalCard methodsFor: 'instance creation' stamp: 'nicolas 6/19/2017 00:46'!printString	^ valor asCommaString ! !!GoalCard methodsFor: 'instance creation' stamp: 'IgnacioRodriguez 6/20/2017 13:01'!playCard: juegojuego setGoal: self.! !!GoalCard methodsFor: 'testing' stamp: 'IgnacioRodriguez 6/17/2017 22:20'!isMetBy: aSet	|interseccion|	"comment stating purpose of message"	interseccion := (valor intersection: aSet).	^(interseccion  size = valor size) and: [interseccion  includesAllOf: valor]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GoalCard class	instanceVariableNames: ''!!GoalCard class methodsFor: 'instance creation' stamp: 'nicolas 6/15/2017 23:29'!new: val	|instance|	instance := self new.	instance inicializar: val.	^ instance! !Object subclass: #MiniFluxxGame	instanceVariableNames: 'jugadores mazo goal winner'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'todo 6/19/2017 19:52'!inicializar: deck playerNames: players cardsPlayers:n"Inicializar jugadores y mazo"|cantCartas|cantCartas :=n.mazo := deck.(mazo size< (players size * n)) ifTrue:[		cantCartas:=0 ].jugadores :=  OrderedCollection new.players do: [:val| jugadores  addLast:((MiniFluxxPlayer new: val) receive: cantCartas  cardsFrom:mazo) ].^self ! !!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'todo 6/19/2017 19:53'!currentPlayer^ jugadores at:1 ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:10'!players^ jugadores ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:48'!playGame[mazo isEmpty ] whileFalse: [ self play1Turn ].! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!winner|aux|aux:=OrderedCollection newFrom: jugadores.goal ifNil:[^nil].aux removeAllSuchThat: [:each | (goal isMetBy: each mesa) not].aux ifNotEmpty:[^aux at: 1].^nil  ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 19:54'!goal^ goal ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:35'!setGoal: newGoalgoal := newGoal. ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:20'!pass|elem|elem := jugadores removeFirst .jugadores addLast: elem.! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:10'!deckSize^ mazo size ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 16:51'!setStrategy: aBlock forPlayer: unJugadorjugadores detect: [:jugador| jugador name equals: unJugador] ifFound:[:jugador|jugador strategy:aBlock].  ! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'todo 6/19/2017 20:30'!play1Turnself currentPlayer pickFrom: mazo .self currentPlayer play:self.self pass.  ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MiniFluxxGame class	instanceVariableNames: ''!!MiniFluxxGame class methodsFor: 'as yet unclassified' stamp: 'todo 6/19/2017 19:13'!withDeck: deck playerNames: players cardsPerPlayer: n|instancia|instancia := self new.instancia inicializar: deck playerNames: players cardsPlayers:n.^instancia ! !Object subclass: #MiniFluxxPlayer	instanceVariableNames: 'nombre mano mesa strategia'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:10'!name^nombre! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:15'!pickFrom: deck|elem|elem := deck removeFirst.mano addLast: elem.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 16:49'!strategy: aBlockstrategia := aBlock.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:10'!handSize^ mano size! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:10'!hasCards^ mano size >= 1! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!mesa^mesa! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!meets: goal	^goal isMetBy: mesa ! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:23'!play: juegostrategia ifNil: [(mano removeFirst ) playCard: juego]. "strategia ifNotNil: (estrategia h:mano t:mesa game:juego) "! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'nicolas 6/19/2017 02:16'!receive: n cardsFrom: deck|cards|cards := deck removeFirst:n.mano addAllLast: cards.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!table^mesa! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!inicializar: nommano := OrderedCollection new.nombre := nom.mesa := OrderedCollection new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MiniFluxxPlayer class	instanceVariableNames: ''!!MiniFluxxPlayer class methodsFor: 'instance creation' stamp: 'nicolas 6/19/2017 02:12'!new: val	|unaInstancia|	unaInstancia := self new.	unaInstancia inicializar: val.	^unaInstancia ! !TestCase subclass: #Test01Cards	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test01Cards methodsFor: 'tests' stamp: 'nicolas 6/18/2017 01:57'!test01	self assert: ((TreasureCard new: #tea) equals: (TreasureCard new: #tea)).	self assert: ((TreasureCard new: #tea) ~= (TreasureCard new: #cookies)).	self assert: ((TreasureCard new: #tea) ~= #tea).		! !!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/18/2017 02:01'!test01_4CardsAreReadable	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: ('*tea*' match: t1 printString).	self assert: ('*cookies*' match: t2 printString). 	self assert: ('*tea*' match: s1 printString).	self assert: ('*milk*' match: s1 printString).! !!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/18/2017 02:00'!test01_2GoalCardsEquality	|t1 t2 t3 s1 s2 s3 s4|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := Set with: t1 with: t2.	s2 := Set with: t2 with: t3.	s3 := Set with: t3 with: t2.	s4 := Set with: t3 with: t1.	self assert: ((GoalCard new: s1) equals: (GoalCard new: s1)).	self assert: ((GoalCard new: s2) equals: (GoalCard new: s3)).   self assert: ((GoalCard new: s2) ~= (GoalCard new: s4)).	self assert: ((TreasureCard new: s1) ~= s1).	self assert: ((Set with: (GoalCard new: s1)) includes: (GoalCard new: s1)).	self assert: ((Set with: (GoalCard new: s2)) includes: (GoalCard new: s1)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/18/2017 02:01'!test01_3MeetingGoals	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: (s1 isMetBy: (Set with: t1 with: t3)).	self assert: (s1 isMetBy: (Set with: t1 with: t2 with: t3)).	self assert: (s1 isMetBy: (Set with: t1 with: t2)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'nicolas 6/19/2017 00:13'!test01_1TreasureCardsEquality	 self assert:((TreasureCard new: #tea) ~= (TreasureCard new: #cookies)).	 self assert:((TreasureCard new: #tea) ~= #tea). 	 self assert:((Set with: (TreasureCard new: #tea)) includes: (TreasureCard new: #tea)).	 self assert:((Set with: (TreasureCard new: #cookies)) includes: (TreasureCard new: #tea)) not.! !TestCase subclass: #Test02Players	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_3ReceiveFromDeck	| ana deck |	ana := MiniFluxxPlayer new: #Ana.	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	ana receive: 2 cardsFrom: deck.	self assert: ana handSize equals: 2.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_2HandAndDeck	| ana goal deck |	ana := MiniFluxxPlayer new: #Ana.	goal := GoalCard new: (Set with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies)).	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	self assert: (goal isMetBy: deck).	ana pickFrom: deck.	self assert: (goal isMetBy: deck) not.	self assert: ana handSize equals: 1.	ana pickFrom: deck.	self assert: ana handSize equals: 2.	self assert: ana hasCards.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:31'!test02_1PlayerCreation	| ana |	ana := MiniFluxxPlayer new: #Ana.	self assert: ana name equals: #Ana.	self assert: ana handSize equals: 0.	self assert: ana hasCards not.	self assert: ana table isEmpty.! !TestCase subclass: #Test03Games	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck ^self class testDeck! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^self class testStrategy2.! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:08'!testStrategy1	^self class testStrategy1! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 6/8/2017 15:00'!test03_5SinglePlayerGame	| game goal |	game := MiniFluxxGame withDeck: self testDeck playerNames: #(Uno) cardsPerPlayer: 3.	goal := GoalCard new: (Set with: (TreasureCard new: #rocket) with: (TreasureCard new: #moon)).	[game winner] whileNil: [game play1Turn].	self assert: game deckSize equals: 7.	self assert: game winner table size equals: 6.	self assert: game winner handSize equals: 3.	self assert: game goal equals: goal.	self assert: game winner name equals: #Uno.	self assert: game currentPlayer equals: game winner.	self assert: (game currentPlayer meets: goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 16:56'!test03_8PlayWholeGameWithReverseDeck	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck reverse playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #cookies)).	self assert: game winner name equals: #Ana.	self assert: game winner handSize equals: 1.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game winner meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_2TooManyCards	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 10.	self assert: game currentPlayer name equals: #Ana.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 0.	self assert: game deckSize equals: 20.! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 6/8/2017 14:53'!test03_6Strategies	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game currentPlayer strategy: st1.	game setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	4 timesRepeat: [game play1Turn].	self assert: game deckSize equals: 8.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Ana.	self assert: game currentPlayer table isEmpty.	self assert: (game players allSatisfy: [:p | p name = #Ana | p table isNotEmpty ]).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:40'!test03_4Play1Turn	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game play1Turn.	self assert: game deckSize equals: 11.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Pedro.! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:30'!test03_7PlayWholeGame	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #milk)).	self assert: game winner name equals: #Juan.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p handSize = 2 ]).	self assert: ((game players detect: [:p | p name = #Juan]) meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_1Initialization	| players game | 	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	self assert: game goal isNil.	self assert: game winner isNil.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 2.	self assert: game deckSize equals: 12.! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/27/2017 10:02'!test03_9GameEndsInADraw	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: (self testDeck remove: (TreasureCard new: #milk) ; yourself) 							                         playerNames: players cardsPerPlayer: 2.	self assert: game deckSize equals: 11.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #love)).	self assert: game winner isNil.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p hasCards not ]).	self assert: (game players allSatisfy: [:p | (p meets: game goal) not ]).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 14:32'!test03_3Pass	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game pass.	self assert: game currentPlayer name equals: #Pedro.	game pass.	self assert: game currentPlayer name equals: #Marina.	game pass.	self assert: game currentPlayer name equals: #Juan.	game pass.	self assert: game currentPlayer name equals: #Ana.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Test03Games class	instanceVariableNames: ''!!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck|   t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10  g0 g1 g2 g3 g4 g5 g6 g7 g8|t0 := TreasureCard new: #chocolate.t1 := TreasureCard new: #rocket.t2 := TreasureCard new: #moon.t3 := TreasureCard new: #cookies.t4 := TreasureCard new: #money.t5 := TreasureCard new: #love.t6 := TreasureCard new: #peace.t7 := TreasureCard new: #milk.t8 := TreasureCard new: #tea.t9 := TreasureCard new: #time.t10 := TreasureCard new: #hammer.g0 := GoalCard new: (Set with: t0 with: t3).g1 := GoalCard new: (Set with: t1 with: t2).g2 := GoalCard new: (Set with: t5 with: t6).g3 := GoalCard new: (Set with: t7 with: t8).g4 := GoalCard new: (Set with: t9 with: t4).g5 := GoalCard new: (Set with: t3 with: t8).g6 := GoalCard new: (Set with: t0 with: t7).g7 := GoalCard new: (Set with: t9 with: t10).g8 := GoalCard new: (Set with: t3 with: t7).^OrderedCollection new add: g4; add: t5; add: t0; add: g3; add: t6; add: t1; add: g8; add: t7; add: t2; add: g1; add: t8; add: t3; add: g0; add: t9; add: t4 ; add: g5; add: t10; add: g6; add: g7; add: g2 ; yourself.! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^[ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ (t union: h) includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy1^ [ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ t includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !Card subclass: #TreasureCard	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!TreasureCard methodsFor: 'instance creation' stamp: 'nicolas 6/11/2017 01:35'!inicializar: val	"comment stating purpose of message"	valor:=val.	type:= #Treasure.! !!TreasureCard methodsFor: 'instance creation' stamp: 'IgnacioRodriguez 6/20/2017 17:21'!playCard: juegojuego currentPlayer mesa addLast: self.! !!TreasureCard methodsFor: 'instance creation' stamp: 'nicolas 6/16/2017 00:44'!hash^ valor hash.! !!TreasureCard methodsFor: 'instance creation' stamp: 'nicolas 6/19/2017 00:46'!printString	^ valor! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TreasureCard class	instanceVariableNames: ''!!TreasureCard class methodsFor: 'instance creation' stamp: 'nicolas 6/15/2017 23:29'!new: val	|instance|	instance := self new.	instance inicializar: val.	^ instance! !